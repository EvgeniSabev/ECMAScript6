<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Модули :: Understanding ECMAScript 6</title>
	<link rel="stylesheet" href="font.css">
</head>
<body>
	<nav>
  <a href="./12_proxies_and_reflection.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./appendix_A.html" title="next chapter">▶</a>
</nav>
	 <header id="header" class="">
	 	<h1><div class="head-num">Глава 13</div>Модули</h1>
	 	<p>Един от най-податливите на грешки и объркващи аспекти на JavaScript е подхода  “сподели всичко” към зареждане на код. Докато другите езици използват понятия, като пакети за дефиниране на обхвата на кода, JavaScript изостава и всичко дефинирано във всеки файл споделя един глобален обхват. Тъй като уеб приложенията стават по-сложни и започват да използват повече JavaScript код, този подход е причина за проблеми със сблъсъци в именуването, сигурността и др. Една от целите на ECMAScript 6 е да реши този проблем и да внесе някакъв ред в JavaScript приложенията. Това е когато модула влиза.</p>
	 </header><!-- /header -->
	 <article>
	 	<h3>Какво е модули?</h3>
	 	<p><em>Modules</em> са JavaScript файлове, които се зареждат в специален режим (за разлика от <em>scripts</em>, които се зареждат по оригинален начин в  JavaScript).Този различен режим е необходим, защото модулите имат много различна семантика от <em>scripts</em>:</p>
	 	<dl>
	 		<dd>
	 			<ol>
	 				<li>Модул кода автоматично минава в строг режим и няма начин да се откажете от <em>strict mode</em>.</li>
	 				<li>Променливи, създадени в най-горното ниво на модула не се добавят автоматично към споделения глобален обхват. Те съществуват само в рамките на обхвата на модула на най-високо ниво.</li>
	 				<li>Стойността на <em>this</em> в най-горното ниво на модула е <em>undefined</em>.</li>
	 				<li>Модулите не позволяват HTML-стил на коментарите в рамките на кода(останала особеност от ранните дни на браузъра).</li>
	 				<li>Модулите трябва да <em>export</em> (изнасят) всичко, което трябва да бъде на разположение на кода извън модула.</li>
					 <li>Модули могат да <em>import</em> (внасят) обвързване от други модули.</li>
	 			</ol>
	 		</dd>
	 	</dl>
	 	<p>Тези различия може да изглеждат дребни на пръв поглед, но те представляват значителна промяна в начина, по който JavaScript кода се зарежа и оценява, което ще обсъдим в тази глава. Истинската сила на модулите е способността да изнасят и внасят само обвързванията, които ви трябват, а не всичко от един файл. Добро разбиране на <em>export</em> и <em>import</em> е основно за разбирането на това, по което модулите се различават от <em>scripts</em>.</p>
	 	<h3>Basic Exporting</h3>
	 	<p>Ключовата дума <em>export</em> се използва да изложи части от публикуван код към други модули. В най-простия случай, можете да поставите <em>export</em> пред всяка променлива, функция или клас декларация за да ги изнесете от модула. Например:</p>
	 	<dl>
	 		<dd><pre class="highlight">
// export data
<span class="code">export var</span> color = "red";
<span class="code">export let</span> name = "Nicholas";
<span class="code">export const</span> magicNumber = 7;

// export function
<span class="code">export function</span> sum(num1, num2) {
    <span class="code">return</span> num1 + num1;
}

// export class
<span class="code">export class</span> Rectangle {
    constructor(length, width) {
        <span class="code">this</span>.length = length;
        <span class="code">this</span>.width = width;
    }
}

<span class="comment"><em>// тази функция е частна за модула</em></span>
<span class="code">function</span> subtract(num1, num2) {
    <span class="code">return</span> num1 - num2;
}

<span class="comment"><em>// дефиниране на функция....</em></span>
<span class="code">function</span> multiply(num1, num2) {
    <span class="code">return</span> num1 * num2;
}

<span class="comment"><em>// ... и изнасянето и по-късно</em></span>
<span class="code">export</span> { multiply };
	 		</pre></dd>
	 	</dl>
	 	<p>Има няколко неща, които могат да се забележат в този пример:
	 	Всяка декларация е точно същата, както би била в противен случай без ключовата дума <em>export</em>. Всяка експортирана функция или клас също има име. Това е защото изнесените декларации на функции и класове  изискват име. Не можем да изнасяме анонимни функции или класове, използващи този синтаксис (освен ако не се използва ключовата дума <em>default</em>, обсъдена по-подробно в секцията "<em>Default</em> стойности в модули").</p>
		 <p>На следващо място, помислете за <em>multiply()</em> функцията, която не е предназначена за износ, когато е дефинирана. Това работи, защото не е необходимо винаги да се изнася декларация. Можете също да изнасяте референции. И накрая обърнете внимание, че този пример не се изнася <em>subtract()</em> функцията. Тази функция няма да бъде достъпна извън този модул, защото всички променливи, функции или класове, които не са изрично изнесени остават скрити в модула.</p>
		 <h3>Basic Importing</h3>
		 <p>След като имаме модул с <em>export</em>, имаме достъп до функционалноста в друг модул с помощта на ключовата дума <em>import</em>. Двете части на <em>import</em> декларацията са идентификатори, които се импортират и модула, от които трябва да се внесат тези идентификатори. Това е основната форма на отчета:</p>
		 <dl>
	 		<dd><pre class="highlight">
<span class="code">import</span> { identifier1, identifier2 } from "./example.js";
	 		</pre></dd>
	 	</dl>
		 <p>Фигурните скоби след <em>import</em> показват обвързването на вноса от даден модул. Ключовата дума <em>from</em> показва модула, от която се внася дадено обвързване. Модула се определя от <em>string</em>, представляващ пътя към модула (наречен модул спецификатор). Браузърите използват същия път формат, който може да се подаде към &lt;script&gt; елемент, което означава, че трябва да включва файлово разширение. Node.js, от друга страна, следва своята традиционна конвенция за разграничаване между локални файлове и пакети на базата на префикс за файловата система. На пример <em>example</em> ще бъде пакет, a <em>./example.js</em> ще бъде локален файл.</p>
		 <dl>
	 		<dd><div class="info">
         <img src="./img/info.jpg" alt="info">
       </div><strong>Списъкът на обвързване за внос изглежда подобно на <em>destructured</em> обект, но не е само това..</strong></dd>
	 	</dl>
		 <p>При внос на обвързване от модул, обвързването действа все едно, че дефиниран посредством <em>const</em>. Това означава, че не можете да дефинирате друга променлива със същото име (включително внос на друго обвързване със същото име), използва се  идентификатор преди <em>import</em> изявлението или промяна на стойността му.</p>
		 <h3>Importing a Single Binding</h3>
	 	<p>Да предположим, че първият пример в раздела "Basic Експорт" е в един модул, наречен "example.js". Можем да внесем и използваме идентификатори от този модул по редица начини. Например, можем просто да внесем един идентификатор:</p>
	 	<dl>
	 		<dd><pre class="highlight">
// import just one
<span class="code">import</span> { sum } from "./example.js";

console.log(sum(1, 2));     // 3

sum = 1;        // error
	 		</pre></dd>
	 	</dl>
	 	<p>Въпреки че, <em>example.js</em> изнася повече от една функция, този пример внася само <em>sum()</em> функцията. Ако се опитаме да присвоим нова стойност на <em>sum</em>, резултата е грешка, тъй като не можем да присвояваме на импортираните идентификатори.</p>
		 <dl>
	 		<dd><div class="worning">
					<img src="./img/worning.jpg" alt="worning">
       </div><strong>Уверете се, че сте включили  /, ./, или .../ в началото на файла, който внасяте за по-добра съвместимост между браузъра и Node.js.</strong></dd>
	 	</dl>
		 <h3>Importing Multiple Bindings</h3>
	 	<p>Ако искате да внесете множество обвързвания от "example" модула, трябва изрично да ги изброите, както следва:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
// import multiple
<span class="code">import</span> { sum, multiply, magicNumber } from "./example.js";
console.log(sum(1, magicNumber));   // 8
console.log(multiply(1, 2));        // 2
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Тука, три идентификатора се внасят от <em>example</em> модула: <em>sum, multiply</em> и <em>magicNumber</em>. След това се използват, все едно са дефинирани на място.</p>
		 <h3>Importing All of a Module</h3>
	 	<p>Има също така и специален случай, който позволява да внесем целия модул, като обект. Всичко от износа след това е на разположение в този обект, като свойства. Например:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
// import everything
<span class="code">import</span>* as example from "./example.js";
console.log(example.sum(1,
        example.magicNumber));          // 8
console.log(example.multiply(1, 2));    // 2
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>В този код, всички изнесени обвързвания от <em>example.js</em> са заредени в обект, наречен <em>example</em>. Изнесените имена <em>sum(), multiple()</em> и <em>magicNumber</em> след това са достъпни, като свойства на <em>example</em>. Този формат на внос се нарича <em>namespace import</em>, тъй като <em>example</em> обектът не съществува вътре в файла <em>example.js</em> и вместо това е създаден, за да бъде използван, като <em>namespace</em> обект за всички изнесени членовете <em>example.js</em>.</p>
	 	<p>Имайте предвид, че без значение колко пъти използвате модул в <em>import</em> изявлението, модулът ще бъде изпълнен само веднъж. След, като се изпълни кода за внос на модула, инстанцията на модула се съхранява в паметта и се използва повторно всеки път, когато друго <em>import</em> изявление има препратки към него. Помислете върху следното:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">import</span> { sum } from "./example.js";
<span class="code">import</span> { multiply } from "./example.js";
<span class="code">import</span> { magicNumber } from "./example.js";
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Въпреки, че има три <em>import</em> изявления в този модул, <em>example.js</em> ще се изпълни само веднъж. Ако други модули в същото приложение внасят обвързвания от <em>example.js</em>, тези модули ще използват същия модул инстаниця, който този код използва.</p>
		 <div class="aside">
			 <h3>Модул синтаксис ограничения</h3>
			 <p>Важно ограничение на <em>export</em> и <em>import</em> е, че те трябва да бъдат използвани извън други изявления и функции. Например, този код ще направи синтактична грешка:</p>
			 <dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">if</span> (flag) {
<span class="code">export</span> flag;    // syntax error
}
	 			</pre>
	 		</dd>
	 	</dl>
		 <p>Декларацията за <em>export</em> е вътре в <em>if</em> изявление, което не е позволено. Износът не може да бъде условен или направен динамично по никакъв начин. Една от причините да съществува модул синтаксис е да позволи на JavaScript машината, <em>staticly</em> да определи какво да бъде изнесено. Като такъв, можете да използвате <em>export</em> само на най-високото ниво в модула.</p>
		 <p>По същия начин не можете да използвате <em>import</em> във вътрешността на декларация. Можете да го използвате само на най-високото ниво. Това означава, че този код също дава синтактична грешка:</p>
		 <dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">function</span> tryImport() {
<span class="code">import</span> flag from "./example.js";    // syntax error
}
	 			</pre>
	 		</dd>
	 	</dl>
		 <p>Не можете да внасяте динамично обвързвания по същата причина, поради която не можете да изнасяте динамично обвързвания. Ключовите думи <em>export</em> и <em>import</em> са предназначени да бъдат статични, така че инструменти, като текстови редактори да могат лесно да кажат каква информация е разположение от модул.</p>
		 </div>
	 	<h3>A Subtle Quirk of Imported Bindings</h3>
	 	<p>В ECMAScript 6 <em>import</em> изявленията създават  обвързвания само за четене на променливи, функции и класове, а не просто да се позовават на първоначалното обвързване, като нормални променливи. Въпреки, че модула, който внася обвързването не може да променя стойността си, модула, който изнася идентификатор може. Да предположим например, че искате да използвате този модул:</p>
	 			<pre class="highlight">
<span class="code">export</span> var name = "Nicholas";
<span class="code">export function</span> setName(newName) {
    name = newName;
}
	 			</pre>
	 	<p>Когато импортираме тези две обвързвания, можем да видим, че <em>setName()</em> функцията е в състояние да промени стойността на <em>name</em>:</p>
	 			<pre class="highlight">
<span class="code">import</span> { name, setName } from "./example.js";

console.log(name);       // "Nicholas"
setName("Greg");
console.log(name);       // "Greg"

name = "Nicholas";       // error
	 			</pre>
	 	<p>Извикването на <em>setName("Greg")</em> се връща обратно в модула, от който <em>setName()</em> се изнася и изпълнява там настройването на <em>name</em> към "Greg". Имайте в предвид, че тази промяна се отразява автоматично върху вноса на <em>name</em> обвързването. Това е защото <em>name</em> е локално име за идентификаторна на изнасяния <em>name</em>. <em>name</em>, използвано в кода по-горе и <em>name</em>, използвано в модула се внасят. но не са еднакви.</p>
	 	<h3>Преименуване на износа и вноса</h3>
	 	<p>Понякога може да не искате да използвате оригиналното име на променлива, функция или клас внесени от един модул. За щастие, можете да промените името на износа, както по време на износа, така и по време на вноса.</p>
	 	<p>В първия случай, да предположим, че имате функция, която искате да изнасете с различно име. Можете да използвате, ключовата дума <em>as</em> за да зададете името на функцията, което трябва да се знае извън модула:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">function</span> sum(num1, num2) {
    <span class="code">return</span> num1 + num2;
}

<span class="code">export</span> { sum as add };
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Тука, функцията <em>sum()(sum е локално име)</em> се изнася, като <em>add()(add е exported name)</em>. Това означава, че ако друг модул иска да внася тази функция, ще трябва да използва името <em>add</em>:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">import</span> { add } from "./example.js";	 				
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Ако внасящия модул на функцията иска да използва друго име, той също може да използва <em>as</em>:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">import</span> { add as sum } from "./example.js";
console.log(<span class="code">typeof</span> add);            // "undefined"
console.log(sum(1, 2));             // 3
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Този код внася <em>add()</em> функцията (<em>import name</em>) и го преименува на <em>sum() (local name)</em>. Това означава, че няма идентификатор, с име <em>add</em> в този модул.</p>
	 	
	 	<h3>Стойности по подразбиране в модули</h3>
	 	<p>Модул синтаксиса е наистина оптимизиран за износ и внос на стойности по подразбиране от модули, като този модел е често срещан и в други модулни системи, като CommonJS (друга спецификация за използване на JavaScript извън браузъра). Стойността по подразбиране за един модул е променлива, функция или клас, които са посочени с ключовата дума <em>default</em> и можете да зададете само един износ по подразбиране за модул. Използването на ключовата дума <em>default</em> за износ на множество е синтактична грешка.</p>
		 <h4>Exporting Default Values</h4>
		 <p>Ето един прост пример, който използва ключовата дума <em>default</em>:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">export default function</span>(num1, num2) {
    <span class="code">return</span> num1 + num2;
}
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Този модул изнася функция, като негова стойност по подразбиране. Ключовата дума <em>default</em> показва, че това е износ по подразбиране. Функцията не изисква име, защото самия модул представлява функцията.</p>
	 	<p>Можете също да зададете идентификатор по подразбиране за износ, като го поставите след <em>export default</em>, като например:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">function</span> sum(num1, num2) {
    <span class="code">return</span> num1 + num2;
}

<span class="code">export default</span> sum;
	 			</pre>
	 		</dd>
	 	</dl>
		 <p>Тука <em>sum()</em> функцията първо се дефинира и по-късно се изнася, като стойност по подразбиране на модула. Вие може да искате да изберете този подход, ако стойността по подразбиране трябва да бъде изчислена.</p>
		 <p>Третият начин да зададете идентификатор, като износ по подразбиране е с помощта на преименуване на синтаксиса, както следва:</p>
		 <dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">function</span> sum(num1, num2) {
    <span class="code">return</span> num1 + num2;
}

<span class="code">export</span> { sum as <span class="code">default</span> };
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Идентификаторът <em>default</em> има специално значение в преименуването на износа и показва стойноста, която трябва да бъде по подразбиране за модула. Понеже <em>default</em> е ключова дума в JavaScript, тя не може да се използва за променлива, функция или име на клас (тя може да се използва, като име на свойство). Така че използването на <em>default</em> за преименуване на износ е специален случай, който създава съгласуваност с това, как се дефинира <em>non-default</em> износ. Този синтаксис е полезен, ако искате да използвате една експортна декларация за задаване на множество износ, включително по подразбиране, наведнъж.</p>
		 <h4>Importing Default Values</h4>
		 <p>Можете да внесете стойност по подразбиране от модул, като използвате следния синтаксис:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="comment"><em>// внос по подразбиране</em></span>
<span class="code">import</span> sum from "./example.js";

console.log(sum(1, 2));     // 3
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Това <em>import</em> изявление внася по подразбиране от модула <em>example.js</em>. Обърнете внимание, че не се използват фигурни скоби, за разлика от <em>non-default import</em>. Локалното име <em>sum</em> се използва за представяне на функцията, като <em>default</em> износ на модула. Този синтаксис е най-чист и създателите на ECMAScript 6 очакват той да бъде доминиращ вид на внос в интернет, което ви позволява да използвате вече съществуващ обект.</p>
		 <p>За модули, които изнасят <em>default</em> или <em>non-default</em>, можете да импортирате всички изнесени обвързвания с една декларация. Например да предположим, че имате този модул:</p>
		 <dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">export let</span> color = "red";

<span class="code">export default function</span>(num1, num2) {
    <span class="code">return</span> num1 + num2;
}
	 			</pre>
	 		</dd>
	 	</dl>
		 <p>Можете да импортирате <em>color</em> и функция по подразбиране с помощта на следната <em>import</em> декларация:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">import</span> sum, { color } from "./example.js";

console.log(sum(1, 2));     // 3
console.log(color);         // "red"
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Запетаята разделя локалното име по подразбиране от не по подразбиране, което е заобиколено от фигурни скоби. Имайте предвид, че по подразбиране трябва да бъде преди не-по подразбиране в <em>import</em> изявлението</p>
	 	<p>Както при изнасяне по подразбиране, така и при внасяне по подразбиране може да импортирате <em>default</em> с помощта на синтаксиса за преименуване.</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="comment"><em>// еквивалентно на предишния пример</em></span>
<span class="code">import</span> { <span class="code">default</span> as sum, color } from "example";

console.log(sum(1, 2));     // 3
console.log(color);         // "red"
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>В този код износа по подразбиране (<em>default</em>) е преименуван на <em>sum</em> и допълнителния износ на <em>color</em> също се внася. Този пример е еквивалентен на предишния</p>
	 	<h3>Re-exporting a Binding</h3>
	 	<p>Възможно е някой път да искате да реекспортирате нещо, което модула е внесъл (например, ако се създаде библиотека от няколко по-малки модули). Можете да изнесете повторно внесената стойност с моделите, които вече дискутирахме в тази глава, както следва:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">import</span> { sum } from "./example.js";
<span class="code">export</span> { sum }
	 				
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Това работи, но има една декларация, която може да направи същото нещо:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">export</span> { sum } from "./example.js";
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Тази форма на <em>export</em> се оглежда в указания модул за декларация на <em>sum</em> и след това я изнася. Разбира се можем да изберем различно име за изнасяне на едно и също нещо.</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">export</span> { sum as add } from "./example.js";
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Тука, <em>sum</em> се внася от <em>"./example.js"</em> и след това се изнася, като <em>add</em>.</p>
	 	<p>Ако искате да изнасяте всичко от друг модул, можем да използваме модела със звезда * :</p>
	 	<dl>
	 		<dd><pre class="highlight">
<span class="code">export</span> * from "./example.js";	 			
	 		</pre></dd>
	 	</dl>
	 	<p>Чрез изнасяне на всичко, което включва по подразбиране, както и всяко име за износ, което може да повлияе на това, което може да изнесете от вашия модул. Например, ако <em>"./example.js"</em> има износ по подразбиране, вие можете да дефинирате нов износ по подразбиране, когато използвате този синтаксис.</p>
	 	<h3>Внос без обвързване</h3>
	 	<p>Някои модули не могат да изнасят нищо и вместо това, правят само модификации на обектите в глобалния обхват. Въпреки, че най-високото ниво променливи, функции и класове вътре в модула, не попадат автоматично в глобалния обхват, това не означава, че модулите не могат да получат достъп до глобалния обхват. Общите дефеници на вградени обекти, като <em>Array</em> и <em>Object</em> са достъпни в един модул и промени в тези обекти ще бъдат отразени в други модули.</p>
	 	<p>Например, искате да добавите метод за всички масиви, наречен <em>pushAll()</em>, можете да дефинирате модул, като този:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="comment"><em>// код на модул без износ и внос</em></span>
<span class="code">Array</span>.prototype.pushAll = <span class="code">function</span>(items) {

    <span class="comment"><em>// елементите тябва да бъдат масив</em></span>
    <span class="code">if</span> (!<span class="code">Array</span>.isArray(items)) {
        <span class="code">throw new</span> TypeError("Argument must be an array.");
    }

    <span class="comment"><em> // използване на вграден push() и оператор spread</em></span>
    <span class="code">return this</span>.push(...items);
};
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Това е валиден модул, въпреки, че няма износ и внос. Този код може да се използва, както от модул, така и от скрипт. Тъй като не изнася нищо, можем да използваме опростен внос за изпълнение на кода в модул, без импортни обвързвания:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">import</span> "./example.js";

<span class="code">let</span> colors = ["red", "green", "blue"];
<span class="code">let</span> items = [];

items.pushAll(colors);
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Този код внася и изпълнява модула, съдържащ <em>pushAll()</em> метода, така <em>pushAll()</em> се добавя към прототипа на масив. Това означава, че <em>pushAll()</em> е вече на разположение за използване от всички масиви във вътрешността на този модул.</p>
	 	<dl>
	 		<dd><div class="info">
         <img src="./img/info.jpg" alt="info">
       </div><strong>Внос без обвързвания най-вероятно ще бъде използван за създаване на <em>polyfills</em> и <em>shims</em>.</strong></dd>
	 	</dl>
		 <h3>Зареждане на модули</h3>
		 <p>Докато ECMAScript 6 определя синтаксиса за модули, той не определя как да ги заредите. Това е част от сложността на дадена спецификация, която е би трябвало да бъде последователна към средите за изпълнение. Вместо да се опитва да създаде единна спецификация, която да работи във всички JavaScript среди, ECMAScript 6 определя само синтаксиса и контекста на механизъма за зареждане на не определена вътрешна операция, наречена HostResolveImportedModule. Уеб браузърите и Node.js са оставени да решат, по какъв начин да се приложи HostResolveImportedModule, което да има смисъл за съответните среди.</p>
		 <h3>Използване на модули в Уеб Браузъри</h3>
		 <p>Дори преди ECMAScript 6 уеб браузърите имат множество начини за включване на JavaScript в уеб приложения. Тези <em>script</em> опции за зареждане са:</p>
		 <dl>
	 		<dd>
	 			<ol>
	 				<li>Зареждане на JavaScript код на файлове с помощта на &lt;script&gt; елементa с атрибут <em>src</em>, уточняващ място от което да се зареди кода.</li>
	 				<li>Включване на JavaScript код <em>inline</em> използвайки &lt;script&gt; елементa без <em>src</em> атрибут.</li>
	 				<li>Зареждане на JavaScript код на файлове за изпълнение, като </em>workers</em> (също като <em>web worker</em> или <em>service worker</em>).</li>
	 			</ol>
	 		</dd>
	 	</dl>
		 <p>За пълната поддръжка на модули, уеб браузърите трябваше да актуализират всеки един от тези механизми. Тези данни са определени в HTML спецификацията и ще ги обобщим в този раздел.</p>
		 <h4>Използване на модули със &lt;script&gt;</h4>
		<p>Поведението по подразбиране на &lt;script&gt; елемента е да  зареди JavaScript файлове, като скриптове (не модули). Това се случва, когато <em>type</em> атрибутът липсва или когато <em>type</em> атрибутът съдържа тип JavaScript съдържание (като "text/javascript"). Елементът &lt;script&gt; тогава може да изпълни <em>inline</em> код или зареди файл, указан в <em>src</em>. В подкрепа на модули, "module" стойността е добавенa, като <em>type</em> опция. Определянето на <em>type</em> за "module", казва на браузъра да зареди целия <em>inline</em> код или код, съдържащи се във файл, указан от <em>src</em>, като модул вместо скрипт. Ето един прост пример:</p>
		<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="comment">&lt;!-- load a module JavaScript file --&gt;</span>
&lt;<span class="code">script type</span>="module" <span class="code">src</span>="module.js"&gt; &lt;/<span class="code">script</span>&gt;

<span class="comment">&lt;!-- include a module inline --&gt;</span>
&lt;<span class="code">script type</span>="module"&gt;
<span class="code">import</span> { sum } from "./example.js";

<span class="code">let</span> result = sum(1, 2);
&lt;/<span class="code">script</span>&gt;
	 			</pre>
	 		</dd>
	 	</dl>
		 <p>Първият &lt;script&gt; елемент в този пример зарежда файл от външен модул, с помощта на <em>src</em> атрибута. Единствената разлика от зареждане със скрипт е, че "module" е даден, като <em>type</em>. Вторият &lt;script&gt; елемент съдържа модул, който е включен директно в уеб страницата. Променливата <em>result</em> не е изложена глобално, защото тя съществува само в рамките на модула (както е определен от &lt;script&gt; елемента) и следователно не се добавя към <em>window</em>, като свойство.</p>
		 <p>Както можете да видите, включването на модули в уеб страници е сравнително просто и подобно на включването на скриптове. Въпреки това има някои разлики в това, как са зареждат модули.</p>
		  <dl>
	 		<dd><div class="info">
         <img src="./img/info.jpg" alt="info">
       </div><strong>Може би сте забелязали, че "module" не е тип съдържание, както "text/javascript" типа. Модул JavaScript, сервира файлове със същия тип съдържание, както скрипта на JavaScript файловете, така че не е възможно да се разграничат единствено на базата на типа съдържание. Също така, браузърите игнорират &lt;script&gt; елементи, когато <em>type</em> е непознат, така браузъри, които не поддържат модули автоматично ще игнорират &lt;script type="module"&gt; линията, за осигуряване на по-добра обратна съвместимост.</strong></dd>
	 	</dl>
		 <h4>Поредност на зареждане на модули в Уеб Браузъри</h4>
		 <p>Модулите са уникални с това, за разлика от скриптовете, че те могат да използват <em>import</em> за да се уточни, че други файлове трябва да бъдат заредени, за да се изпълняват правилно. В подкрепа на тази функционалност, &lt;script type="module"&gt; винаги действа, както ако се прилага атрибутът <em>defer</em>.</p>
		 <p>Атрибута <em>defer</em> е по избор при зареждане на скрипт файлове, но винаги се прилага при зареждане на модул файлове. Модул файловете започват изтеглянето веднага, след като HTML анализатора срещне &lt;script type="module"&gt; със <em>src</em> атрибут, но не ги изпълняват, до като документът не е напълно анализиран. Модулите също се изпълняват в реда, в който се появяват в HTML файла. Това означава, че първият &lt;script type="module"&gt; винаги гарантирано се изпълнява преди втория, дори ако един модул съдържа <em>inline</em> код вместо да го уточните със <em>src</em>. Например:</p>
		 <dl>
	 		<dd>
	 			<pre class="highlight">
<span class="comment">&lt;!-- this will execute first --&gt;</span>
&lt;<span class="code">script type</span>="module" <span class="code">src</span>="module1.js"&gt; &lt;/<span class="code">script</span>&gt;

<span class="comment">&lt;!-- this will execute second  --&gt;</span>
&lt;<span class="code">script type</span>="module"&gt;
<span class="code">import</span> { sum } from "./example.js";

<span class="code">let</span> result = sum(1, 2);
&lt;/<span class="code">script</span>&gt;

<span class="comment">&lt;!-- this will execute third --&gt;</span>
&lt;<span class="code">script type</span>="module" <span class="code">src</span>="module2.js"&gt; &lt;/<span class="code">script</span>&gt;
	 			</pre>
	 		</dd>
	 	</dl>
		 <p>Тези три &lt;script&gt; елемента се изпълняват в реда, по който са определени, така че <em>module1.js</em> гарантирано ще се изпълни преди <em>inline</em> модула и <em>inline</em> модула гарантирано ще се изпълни преди <em>module2.js.</em></p>
		 <p>Всеки модул може да внася от един или повече други модули, което усложнява материята. Ето защо модулите първо се анализират напълно, за да се идентифицират всички <em>import</em> декларации. Всяка <em>import</em> декларация след това започва донасяне (от мрежата или от кеша), но модула не се изпълнява, докато всички <em>import</em> ресурси първо не са заредени и изпълнени.</p>
		 <p>Всички модули, както тези, които изрично включват използване на &lt;script type="module"&gt; и тези, които мълчаливо включват използване на <em>import</em> се зареждат и изпълняват по ред. В предишния пример, последователноста на пълното зареждане е:</p>
		 <dl>
	 		<dd>
	 			<ol>
	 				<li>Изтегляне и анализиране на <em>module1.js.</em></li>
	 				<li>Рекурсивно изтегляне и анализиране на <em>import</em> ресурси в <em>module1.js.</em>.</li>
	 				<li>Анализиране на <em>inline</em> модула.</li>
                    <li>Рекурсивно изтегляне и анализиране на <em>import</em> ресурси в <em>inline</em> модула.</em>.</li>
					<li>Изтегляне и анализиране на <em>module2.js.</em></li>
					<li>Рекурсивно изтегляне и анализиране на <em>import</em> ресурси в <em>module2.js.</em>.</li>
				</ol>
	 		</dd>
	 	</dl>
		 <p>След като зареждането завърши, нищо не се изпълнява докато документът не е напълно анализиран. След като анализирането на документа завърши, се случват следните действия:</p>
		 <dl>
	 		<dd>
	 			<ol>
	 				<li>Рекурсивно изпълнение на <em>import</em> ресурсите за <em>module1.js.</em></li>
	 				<li>Изпълнение на <em>module1.js.</em>.</li>
	 				<li>Рекурсивно изпълнение на <em>import</em> ресурсите за <em>inline</em> модула.</li>
                    <li>Изпълнение на <em>inline</em> модула.</em>.</li>
					<li>Рекурсивно изпълнение на <em>import</em> ресурсите за <em>module2.js.</em></li>
					<li>Изпълнение на <em>module2.js.</em>.</li>
				</ol>
	 		</dd>
	 	</dl>
		 <p>Забележете, че <em>inline</em> модула действа, като другите два модула с изключение на това, че кодът не трябва да бъде изтеглен първо. Иначе, последователността на зареждамето на <em>import</em> ресурси и изпълнението на модули е точно същото.</p>
		 <dl>
	 		<dd><div class="info">
         <img src="./img/info.jpg" alt="info">
       </div><strong>Атрибутът <em>defer</em> се игнорира в &lt;script type="module"&gt;, защото той вече се държи, сякаш <em>defer</em> се прилага.</strong></dd>
	 	</dl>
		 <h4>Асинхронно зареждане на модули в Уеб Браузъри</h4>
		 <p>Вие може вече да сте запознати с <em>async</em> атрибут на &lt;script&gt; елементa. Когато се използва със скриптове, <em>async</em> предизвиква скрипт файла да се изпълни веднага, след като файлът е напълно изтеглен и анализиран. Реда на <em>async</em> скриптовете в документа не се отразява на реда, по който се изпълняват скриптовете, все пак. Скриптовете винаги се изпълняват веднага, след като приключи изтеглянето, без да чакат документа да завърши анализирането.</p>
		 <p><em>Async</em> атрибута може да бъде приложен на модули. Използване на <em>async</em> в &lt;script type="module"&gt; предизвиква модула да се изпълни по начин, подобен на скрипт. Единствената разлика е, че всички <em>import</em> ресурси за модула са изтеглени преди самия модул да е изпълнен. Това гарантира, че всички ресурси за модула, от които се нуждае за да функционира, ще бъдат изтеглени преди изпълнението на модула; просто не може да се гарантира, кога модулът ще се изпълни. Да разгледаме за следния код:</p>
		 <dl>
	 		<dd>
	 			<pre class="highlight">
<span class="comment">&lt;!-- no guarantee which one of these will execute first --&gt;</span>
&lt;<span class="code">script type</span>="module" <span class="code">async</span> <span class="code">src</span>="module1.js"&gt; &lt;/<span class="code">script</span>&gt;
&lt;<span class="code">script type</span>="module" <span class="code">async</span> <span class="code">src</span>="module2.js"&gt; &lt;/<span class="code">script</span>&gt;
	 			</pre>
	 		</dd>
	 	</dl>
		 <p>В този пример има два модул файла заредени асинхронно. Не е възможно да се каже, кой модул ще се изпълни първи, просто като се гледа този код. Ако <em>module1.js</em> завърши първи изтеглянето (включително всички свои <em>import</em> ресурси), тогава той ще се изпълни първи. Ако <em>module2.js</em> завърши първи изтеглянето, тогава този модул ще се изпълни първи.</p>
		 <h4>Зареждане на модули, като Workers</h4>
		 <p><em>Workers</em>, като <em>web workers</em> и <em>service workers</em>, изпълняват JavaScript код извън контекста на уеб страницата. Създаването на нов <em>worker</em> включва създаването на нова инстанция <em>worker</em> (или друг клас) и подаване на местоположението на JavaScript файл. По подразбиране, механизъма за зареждане е да зареди файловете, като скриптове, като този:</p>
		 <dl>
	 		<dd>
	 			<pre class="highlight">
<span class="comment"><em>// load script.js as a script</em></span>
<span class="code">let</span> worker = <span class="code">new</span> Worker("script.js");
	 			</pre>
	 		</dd>
	 	</dl>
		 <p>В подкрепа на зареждането на модули, програмистите на стандарта HTML, добавят втори аргумент към този конструктор. Вторият аргумент е обект с <em>type</em> свойство със стойност по подразбиране "script". Можете да зададете на <em>type</em> "module" за да зареди модул файлове:</p>
		 <dl>
	 		<dd>
	 			<pre class="highlight">
<span class="comment"><em>// load module.js as a module</em></span>
<span class="code">let</span> worker = <span class="code">new</span> Worker("module.js", { type: "module" });
	 			</pre>
	 		</dd>
	 	</dl>
		 <p>Този пример зарежда <em>module.js</em>, като модул вместо скрипт, като подава втори аргумент с "module", като стойност на <em>type</em> свойството. (Свойство <em>type</em> има за цел да имитира това, как <em>type</em> атрибутът на &lt;script&gt; дефинира модули и скриптове). Вторият аргумент се поддържа за всички видове <em>worker</em> в браузъра.</p>
		 <p><em>Worker</em> модулите обикновено са същите, като <em>worker</em> скриптове, но има и няколко изключения. Първо <em>worker</em> скриптовете са ограничени да бъдат заредени от същия произход, като уеб страницата, в която те са посочени, но <em>worker</em> модулите не са толкова ограничени. Въпреки, че <em>worker</em> модулите имат същото ограничение по подразбиране, те също така могат да заредят файлове, които имат подходящи Cross-Origin Resource Sharing (CORS) заглавия да позволяват достъп. Второ докато <em>worker</em> скрипта може да използва <em>self.importScripts()</em> метода за зареждане на допълнителни скриптове в <em>worker</em>, <em>self.importScripts()</em> винаги се проваля на <em>worker</em> модули, защото вие трябва да използвате <em>import</em> вместо това.</p>
		 <h4>Browser Module Specifier Resolution</h4>
		 <p>Всички примери в тази глава до този момент използват относителен модул спецификатор на пътя, като ". / example.js'. Браузъри изискват модул спецификаторите да бъдат един от следните формати:</p>
		 <dl>
	 		<dd>
	 			<ul>
	 				<li>Започва с / за разрешаване от главната директория</em></li>
	 				<li>Започва с ./ за разрешаване от текущата директория</li>
	 				<li>Започва с ../ за разрешаване от родителската директория</li>
                    <li>URL формат</li>
				</ul>
	 		</dd>
	 	</dl>
		 <p>Например, да предположим, че имате модул файл, намиращ се на https://www.example.com/modules/module.js, който съдържа следния код:</p>
		 <dl>
	 		<dd>
	 			<pre class="highlight">
<span class="comment"><em>// imports from https://www.example.com/modules/example1.js</em></span>
<span class="code">import</span> { first } from "./example1.js";

<span class="comment"><em>// imports from https://www.example.com/example2.js</em></span>
<span class="code">import</span> { second } from "../example2.js";

<span class="comment"><em>// imports from https://www.example.com/example3.js</em></span>
<span class="code">import</span> { third } from "/example3.js";

<span class="comment"><em>// imports from https://www2.example.com/example4.js</em></span>
<span class="code">import</span> { fourth } from "https://www2.example.com/example4.js";
	 			</pre>
	 		</dd>
	 	</dl>
		 <p>Всеки спецификаторите на модула в този пример е валиден за използване в браузър, включително пълният URL адрес в последния ред (трябва да се уверете, че <em>www2.example.com</em> правилно e конфигурирал <em>Cross-Origin Resource Sharing (CORS)</em> заглавията, за да позволи кръстосано домейн зареждане). Това са единствените модул спецификатор формати, които браузърите могат да разрешат по подразбиране (въпреки че, спецификацията за зареждането не е още завършена, модул ще предоставят начини за разрешаване на други формати). Това означава, че някои нормално изглеждащи модул спецификатори, всъщност са невалидни в браузъри и ще доведе до грешка, като например:</p>
		 <dl>
	 		<dd>
	 			<pre class="highlight">
<span class="comment"><em>// invalid - doesn't begin with /, ./, or ../</em></span>
<span class="code">import</span> { first } from "example.js";

<span class="comment"><em>// invalid - doesn't begin with /, ./, or ../</em></span>
<span class="code">import</span> { second } from "example/index.js";
	 			</pre>
	 		</dd>
	 	</dl>
		 <p>Всеки един от тези модул спецификатори, не може да се зареди от браузъра. Двата модул спецификатора са в невалиден формат (липсват правилните начални характери), въпреки че и двата ще работят, когато се използват, като стойност на <em>src</em> в &lt;script&gt; <em>tag</em>. Това е умишлена разлика в поведението между &lt;script&gt; и <em>import</em>.</p>
	 </article>
	 <footer>
	 	<h3>Обобщение</h3>
	 	<p>ECMAScript 6 добавя модули към езика, като начин за опаковане и капсулиране на функционалност. Модулите се държат различно от скриптовете, тъй като не променят глобалния обхват с техните от най-високо ниво променливи , функции, класове и <em>this</em> е <em>undefined</em>. За да се постигне това поведение, модулите са заредени с помощта на друг режим.</p>
	 	<p>Модула трябва да изнася всяка функционалност, която искате да се направи достъпна за потребителите на модула. Променливи, функции и класове могат да бъдат изнасяни, като има и един  износ по подразбиране разрешен за модули. След износа, друг модул може да внесе всички или някои от изнесените имена. Тези имена действат, като определени от <em>let</em> и така функционират, като блок обвързвания, които не могат да бъдат пре-декларирани в същия модул.</p>
	 	<p>Модулите не са длъжни да изнасят нищо, ако то е за манипулиране на нещо в глобалния обхват. Всъщност можете да внасяте от такъв модул, без въвеждане на някакви обвързвания в модул обхвата.</p>
		<p>Тъй като модулите трябва да се изпълняват в друг режим, браузърите въвеждат &lt;script type="module"&gt; за да сигнализират, че файлът източник или <em>inline</em> кода трябва да бъдат изпълнени, като модул. Модул файлове заредени с &lt;script type="module"&gt; се зареждат, като атрибутът <em>defer</em> се прилага към тях. Модулите също се изпълняват в реда, по който те се появяват в съдържащия документ, след като документът е напълно анализиран.</p>
	 </footer>
	 <nav>
  <a href="./12_proxies_and_reflection.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./appendix_A.html" title="next chapter">▶</a>
</nav>
</body>
</html>